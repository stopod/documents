## リーダブルコード

読んだメモっぽいもの  
タイトル: The Art of Readable Code  
著者: Dustin Boswell  
訳: 角 征 典  

" The Art of Readable Code by Dustin Boswell and Trevor Foucher. Copyright 2012 Dustin Boswell and Trevor Foucher, 978-0-596-80229-5"  

Dustin Boswell. リーダブルコード (Kindle の位置No.99-100). Kindle 版. 

---

### 1章 理解しやすいコード

- コードは理解しやすくなければならない
- コードは他の人が最短時間で理解できるように書かなければならない
---

### 2章 名前に情報を詰め込む

- 明確な単語を選ぶ
  - 「get」はあまり明確な単語ではない
    - 「GetPage()」よりは「FetchPage()」「DounloadPage()」の方が明確

- 汎用的な名前を避ける（あるいは使う状況を選ぶ）
  - retvalには戻り値です以外の情報はない（戻り値なのは自明）
  - 良い名前というのは、「変数の目的や値を表すもの」
  - 汎用的な名前は情報の一時的な保管に限っては問題がない（生存期間が数行）  
  　明確な理由がある場合は別である
  - ループイテレータ（i, j, k, iter...）
    - club_i, members_i, users_iとかci, mi, uiにすると良いらしい（本当か？）

  少しでも時間を使って良い名前を考える習慣をつけるようにすれば、  
  すぐに「命名力」の高まりが感じられるようになるだろう  
  （命名力の高まりってのがおもしろい）

- 抽象的な名前よりも具体的な名前を使う
  - 「ServerCanStart()」よりも「CanListenOnPort()」のほうが具体的である

- 接尾辞や接頭辞を使って情報を追加する
  - 時価やバイト数のように計測できるものがあれば、変数名に単位を入れると良い
  - その他の重要な属性を追加する
    - plaintext, unescaped, utf8, urlenc...
      - すべての変数名に属性を追加しろということではなく、変数の意味を間違えてしまったときに  
        バグになりそうなところにだけ使うことが大切である
  - ミリ秒を表す変数名には、後ろに_msをつける、これからエスケープが必要な変数名には、前にraw_をつける

- 名前の長さを決める
  - 良い名前を選ぶときには、「長い名前を避ける」という暗黙的な制約がある  
  - スコープが小さければ短い名前でもいい
  - 長い名前を入力するのは問題じゃない
    - プログラミングに使うテキストエディタいは「単語補完」機能がついている
  - プロジェクト固有の省略形はダメ
    - docがdocumentで、strがstringであることはプログラマなら分かる
    - 不要な単語を投げ捨てる
      - 「ConvertToString()」を「ToString()」にしても必要な情報は何も損なわれていない

- 名前のフォーマットで情報を伝える
  - 例えばクラスのメンバ変数にアンダースコアをつけて、ローカル変数と区別する  
    （例えばの話）
---

### 3章 誤解されない名前

  - 名前が「他の意味と間違えられることはないだろうか？」と何度も自問自答する
    - 「filter()」  -> 選択するのか除外するのかわからない  
      「選択する」のであればselect()で、「除外する」のであればexlude()にしたほうが良い
    - 「Clip(text, length))」  -> 最後からlength文字を削除か、最大length文字まで切り詰めるかが不明瞭
    - 限界値を含めるときはmin, maxを使う
    - 範囲を指定するときはfirstとlastを使う
    - 包括, 排他的範囲にはbegin, endを使う
---

### 4章 美しさ

  - 3つの原則
    - 読み手が慣れているパターンと一貫性のあるレイアウトを使う
    - 似ているコードは似ているように見せる
    - 関連するコードをまとめてブロックにする

  - メソッドを使って整列をする

  - 縦の線をまっすぐにする
    - 試しにやってみて手間になるようだったら、その時は止めればいい
  - 一貫性と意味のある並び
    - 対応するHTMLフォームのinputフィールドと同じ並び順にする
    - 最重要なものから重要度順に並べる
    - アルファベット順に並べる
      - どの並び順を選ぶにしても、一連のコードでは同じ並び順を使うべき
    - 宣言をブロックにまとめる
      ``` 
      class FrontendServer {
        public: 
          FrontendServer();
          void ViewProfile( HttpRequest* request);
          void OpenDatabase( string location, string user);
          void SaveProfile( HttpRequest* request);
          string ExtractQueryParam( HttpRequest* request, string param);
          void ReplyOK( HttpRequest* request, string html);
          void FindFriends( HttpRequest* request);
          void ReplyNotFound( HttpRequest* request, string error);
          void CloseDatabase( string location);
          ~ FrontendServer();
        };
      ```
        ▽
      ``` 
      class FrontendServer {
        public: 
          FrontendServer();
          ~ FrontendServer();

          // ハンドラ
          void ViewProfile( HttpRequest* request);
          void SaveProfile( HttpRequest* request);
          void FindFriends( HttpRequest* request);

          // リクエストとリプライのユーティリティ
          string ExtractQueryParam( HttpRequest* request, string param);
          void ReplyOK( HttpRequest* request, string html);
          void ReplyNotFound( HttpRequest* request, string error);

          // データベースのヘルパー
          void OpenDatabase( string location, string user);
          void CloseDatabase( string location);
        };
      ```

  - コードを「段落」に分割する  
    文章は複数の段落に分割されている
      - 似ている考えをグループにまとめて、他の考えと分けるため
      - 視覚的な「踏み石」を提供できるから（ページの中で自分の場所を見失わないように）
      - 段落単位で移動できるようになる  
      -> 同じ理由でコードも「段落」に分けるべきである  
      段落ごとに要約コメントを追加してざっと目を通せるようにする

  - 個人的な好みと一貫性  
    最終的には個人の好みになってしまうこともある  
    （例えばクラス定義の開き括弧の位置とか）  
    どちらを選んでもコードの読みやすさに大きな影響はない、  
    ただ2つのスタイルを混ぜてしまうと読みにくくなる  
    -> プロジェクトの規約に従う、一貫性のあるスタイルは「正しい」スタイルよりも大切である
---

### 5章 コメントすべきことを知る

  - コメントの目的は、書き手の意図を読み手に知らせることである
    - 「コードの動作を説明する」ことは目的のごく一部
  
  - コメントするべきでは「ない」こと
    - 価値のないコメント例 -> コードからすぐにわかることをコメントに書かない
      ```
      // Accountクラスの定義
      class Account {
        public: 
          // コンストラクタ
          Account();
          
          // profitに新しい値を設定する
          void SetProfit( double profit);
          
          // このAccountからprofitを返す
          double GetProfit();
      };
      ```
    - コードを見ればどのように動くかわかることでも、コメントを読んだほうが早く理解できることは別
  
  - コメントのためのコメントをしない  
    「宿題に出したコードの関数には必ずコメントをつけろ」なんていう教師がいるとする  
    そうすると、コメントをつけていない裸の関数に罪悪感を抱き、関数の名前と引数をそのまま文章形式でコメントに書き直すようになってしまう
    - 悪い例
      ```
      // 与えられ たsubtreeに含まれるnameとdepthに合致したNodeを見つける。
      Node* FindNodeInSubtree( Node* subtree, string name, int depth);
      ```
    
    - 改善例
      ```
      // 与えられた'name'に合致したNodeかNULLを返す。 
      // もしdepth<= 0ならば、'subtree'だけを調べる。
      // もしdepth == Nならば、'subtree'とその下のN階層まで調べる。
      Node* FindNodeInSubtree( Node* subtree, string name, int depth);
      ```
  
  - ひどい名前はコメントをつけずに名前を変える  
    コメントはひどい名前の埋め合わせに使うものではない
    - 悪い例  
      CleanReply()という関数につけたコメント  
      -> このコメントはcleanの意味を分かりやすく説明しているだけ  
        「制限を課す（enforce limit）」という言葉を関数名に入れたほうが良い
      ```
      // Replyに対してRequestで記述した制限を課す。
      // 例えば、返ってくる項目数や合計バイト数など。
      void CleanReply(Request request, Reply reply);
      ```
    
    - 改善例
      ```
      //'reply'を'request'にある項目数やバイト数の制限に合わせる。
      void EnforceLimitsFromRequest(Request request, Reply reply);
      ```
  
  - 「優れたコード > ひどいコード + 優れたコメント」

  - 自分の考えを記録する  
    優れたコメントというのは「考えを記録する」ためのものである

    - 「監督のコメンタリー」を入れる
        - // このデータだとハッシュテーブルよりもバイナリツリーほのうが40%速かった
        - // 左右の比較よりもハッシュの計算コストのほうが高いようだ
        - ヒューリスティックだと単語が漏れることがあるが仕方ない。100%は難しい
        - このクラスは汚くなってきている
        - サブクラスhogehogeを作って整理したほうが良いかもしれない
      
    - コードの欠陥にコメントをつける
      - // TODO: もっと高速なアルゴリズムを使う
      - // TODO: JPEG以外のフォーマットに対応する
      - プログラマがよく使う記法はいくつかある  ->  大切なのは、そのコードをどうしたいのかを自由にコメントを書くこと
        - TODO: あとで手を付ける
        - FIXME: 既知の不具合があるコード
        - HACK: あまりキレイじゃない解決策
        - XXX: 危険！大きな問題がある
    
    - 定数にコメントをつける
      - 定数を定義するときには、その定数が何をするのか、なぜその値を持っているのかという「背景」が存在する場合が多い  
        定数の値を決めたときに頭の中で考えていたことを記録することが大切  
        例
        ```
        NUM_THREADS = 8 #値は「>= 2 * num_ processors」で十分。

        //合理的な限界値。人間はこんなに読めない。
        const int MAX_RSS_SUBSCRIPTIONS = 1000;

        image_quality = 0.72; // 0.72ならユーザはファイルサイズと品質の面で妥協できる。
        ```
    
    - 読み手の立場になって考える  
      「他の人」というのは、プロジェクトのことを君のように熟知していない人のことである
      - 質問されそうなことを想像する
      - ハマりそうな罠を告知する
      - 「全体像」のコメント
        - そのファイルが何をするのかレベル、短い文章でかまわない
      - 要約コメント
        - コードブロック単位での要約  
          （塊を関数に分割できるならそうする. ひどいコードに優れたコメントをつけるよりも、優れたコードのほうが良い）
    
    - ライターズブロックを乗り越える  
      （行き詰まってしまって、文章が書けないこと）  
      乗り越えるには、とにかく書き始めること  
      例  
      ある関数を作っていて、「やばい、これはリストに重複があったら面倒なことになる」と思ったとして  
      ```
      // やばい. これはリストに重複があったら面倒なことになる。
      ```
      とそのまま書き出せばいい。  
      この中であいまいな表現を置き換える
      - やばい -> 注意
      - これ -> 入力を処理するコード
      - 面倒なことになる -> 実装が難しくなる
      以下が書き換え
      ```
      // 注意：このコードはリストの重複を処理できません（実装が難しいので）
      ```

      コメントを書く作業は3つの手順に分解できる
      - 頭の中にあるコメントをとにかく書きだす
      - コメントを読んで改善が必要なものを見つける
      - 改善する
---

### 6章 コメントは正確で簡潔に

  - コメントは簡潔にしておく
  
  - あいまいな代名詞を避ける
    - 複数のものを指す可能性がある「それ」や「これ」などの代名詞を避ける
  
  - 関数の動作を正確に記述する
    - 行数を返す関数、よりも改行文字(\n)を数えるのほうが正確
  
  - コメントに含める入出力の実例を慎重に選ぶ

  - 「名前付き引数」コメント
    - このようなコメントは必要でないことが多いけど、  
      よくわからない引数を説明するときには、こうするのが手っ取り早い
      ```
      // 引数にコメントをつけて関数を呼び出す
      Connect(/* timeout_ ms = */ 10, /* use_encryption = */ false);
      ```
---

### 7章 制御フローを読みやすくする

条件やループなどの制御フローがないコードは読みやすい。  
他の場所に飛んだり枝分かれしたりするのは複雑なので、コードがすぐに分かりにくくなってしまう  

  - 条件式の引数の並び順  
    `if (lengh >= 10)` <-ほとんどのプログラマはこっちのほうが読みやすいと考える  
    `if (10 <= length)`  

    `while (bytes_received < bytes_expected)` <-これも前者のほうが読みやすい  
    `while (bytes_expected > bytes_received)`  
    - なぜ？
      - 左側 -> 「調査対象」の式、変化する
      - 右側 -> 「比較対象」の式、あまり変化しない
    - 上記の指針は英語の用法と合っている（らしい）
  
  - if/elseブロックの並び順
    - 条件は否定形よりも肯定形を使う
      - 例えば`if (!debug)`よりも`if(debug)`を使う
    - 単純な条件を先に書く、ifとelseが同じ画面に表示されるので見やすい
    - 関心を引く条件や目立つ条件を先に書く

  - 三項演算子  
    複数行が1行にまとまるので良いという意見と、  
    読みにくいしデバッガでステップ実行するのが難しいという意見と、議論の余地がある  

      - 三項演算子が読みやすい例
        ```
        time_str += (hour >= 12) ? "pm" : "am";
        ```

        ```
        // 長くて冗長な感じ
        if (hour >= 12) {
          time_str += "pm";
        } else {
          time_str += "am";
        }
        ```
      
      - if/elseの方が読みやすい例
        ```
        return exponent >= 0 ? mantissa * (1 << exponent) : mantissa / (1 << -exponent);
        ```

        ```
        // 単純な2つの値から1つを選ぶようなものではないので、  
        // if/else文のほうが自然になる
        if (exponent >= 0) {
          return mantissa * (1 << exponent);
        } else {
          return mantissa / (1 << -exponent);
        }
        ```
      
      - do/whileループを避ける
      
      - 関数から早く返す  
        関数で複数のreturn文を使ってはいけないと思っている人がいる。アホくさ。  
        関数から早く返すのはいいことだ。むしろ望ましい時もある。（原文まま、過激派だ）  

        関数の出口を1つにしたいというのは、何らかのクリーンアップコードを確実に実行したいからだろう  
        現代の言語では、こうした仕組みがより洗練された形で提供されている  
      
      - C言語以外ではgotoはほどんど必要ない

      - ネストを浅くする
        - ネストが深くなると、読み手は「精神的スタック」に条件をプッシュしなければいけない。  
        （精神的スタックってなに？）

---

### 8章 巨大な式を分割する

  - 巨大な式は飲み込みやすい大きさに分割する
    - 人間は一度に3~4の「もの」しか考えられないらしい
  
  - 説明変数
    - 式を簡単に分割するには、式を表す変数を使えばいい
      ```
      if line.split(':')[0].strip() == "root":
        ...
      ```
      ▽説明変数を使えば、以下のようになる
      ```
      username = line.split(':')[0].strip()
      if username == "root":
        ...
      ```
  
  - 要約変数
    - 式を説明する必要がない場合でも、式を変数に代入しておくと便利  
      大きなコードの塊を小さな名前に置き換えて、管理や把握を簡単にする変数のことを要約変数と呼ぶ  
      例  
      それほど大きな式ではないが、変数が5つもあるので考えるのにちょっと時間がかかる  
      このコードが言いたいのは「ユーザは文書を所持しているか？」である
      ```
      if (request.user.id == document.owner_id) {
	      // ユーザはこの文書を編集できる
      }
      ```
      ```
      if (request.user.id != document.owner_id) {
	      // 文書は読み取り専用
      }
      ```
      ▽user_owns_documentを最上位に定義したことで、この関数で参照する概念を事前に伝えられる  
        考えやすい
      ```
      final boolean user_owns_document = (request.user.id == document.owner_id);

      if (user_owns_document) {
	      // ユーザはこの文書を編集できる
      }

      if (!user_owns_document) {
	      //文書は読み取り専用
      }
      ```
  
  - ド・モルガンの法則を使う
    - `not (a or b or c) === (not a) and (not b) and (not c)`
    - `not (a and b and c) === (not a) or (not b) or (not c)`
      - 「notを分配してand/orを反転する」と覚えればいいらしい
    
    - 論理式を読みやすくできる例
      ```
      if (!(file_exists && !is_protected)) Error("Sorry, could not read file.");
      ```
      ▽（括弧減る分読みやすいかもしれない）
      ```
      if (!file_exists || is_protected) Error("Sorry, could not read file.");
      ```
  
  - 短絡評価の悪用
    - 「頭が良い」コードに気を付ける  
      あとで他の人がコードを読むときにわかりにくくなる

  - 複雑な論理条件は、「if(a < b)...」のような小さな文に分割した  
    if文の中身が2行以上含まれていない、これは理想的な状態  
    ただ、常に同じことができるとは限らない  
    そんな時は、問題を「否定」したり、反対のことを考えてみる
---

### 9章 変数と読みやすさ  

3つの問題  
変数が多いと変数を追跡するのが難しくなる  
変数のスコープが大きいとスコープを把握する時間が長くなる  
変数が頻繁に変更されると現在の値を把握するのが難しくなる  

- 変数を削除する
  - 結果をすぐ使う中間結果の削除
- 変数のスコープを縮める
  - 変数を数行のコードからしか見えない位置に移動する
- 変数は一度だけ書き込む
  - 変数に一度だけ値を設定すれば、コードが理解しやすくなる  
    （あるいは、constやfinalなどのイミュータブルにする方法を使う）
